# 线性结构和非线性结构

## 线性结构

1. 线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一**的线性关系

2. 线性结构有两种不同的存储结构，即**顺序存储结构**和**链式存储结构**。顺序存储的线性表称为**顺序表**,顺序表种的存储元素是连续的。 链式存储的线性表称为**链表**
   ，链表中的存储元素不一定是连续的，元素节点种存放数据元素以及相邻元素的地址信息。

3. 线性结构常见的有**数组**，**队列**，**链表**和**栈**

## 非线性结构

非线性结构包括:**二维数组**，**多维数组**，**广义表**，**树结构**，**图结构**。

# 3. 稀疏数组和队列

## 3.1 稀疏数组 (Sparse matrix/Sparse array)

### 3.1.1 基本介绍

当一个数稀组中大部分元素是0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。

稀疏数组的处理方法:

1. 记录数组有几行几列，有多少不同的值
2. 把具有不同值的元素的行列及值记录在一个小规模得数组中，从而缩小程序得规模

### 3.1.2 二维数组与系数数组的转化

* 二维数组转稀疏数组的思路
    1. 遍历原始的二位数组，得到有效数据的个数`sum`
    2. 根据sum就可以创建稀疏数组`SparseArr int[sum+1][3]`
    3. 将二位数组的有效数据存入到稀疏数组

* 稀疏数组转二维数组的思路
    1. 读取第一行，根据第一行数据创建原始二位数组
    2. 积蓄读取稀疏数组后几行数据，并赋给原始二位数组

### 3.1.3 代码

[二维数组与稀疏数组相互转化](src/com/yijie/sparsearray/SparseArray.java)

## 3.2队列

### 3.2.1队列介绍

队列是个有序列表，可以用**数组**或者**链表**来实现，队列遵循**FIFO**原则，即先入先出，后入后出

### 3.2.2 数组模拟队列

1. 若使用数组的结构来存储队列数据，则队列数组的声明如下图，其中`maxSize`是该队列的最大容量
2. 因为队列的输出，输入分别从前后端来处理，因此需要两个变量`front`及`rear`分别记录前后端的下标，`front`会随着数据输出改变，而`rear`则随着数据输入而改变
3. 将数据存入队列称为`addQueue`,`addQueue`额处理需要两个步骤:
    1. 将尾指针后移，`rear+1`,当`front=rear`,空
    2. 若尾指针`rear`小于队列最大下标`maxSize-1`，则将数据存入`raer`所指的数据元素中，否则无法存入数据。`rear == maxSize-1`，队列满。

![Example of queue](src/image/Queue.png "Queue")

####代码
[数组模拟队列](src/com/yijie/queue/ArrayQueueDemo.java)

#### 数组模拟环形队列
1. 目前的数组只可使用一次，没有达到复用的效果
2. 将这个数组使用算法，改进成一个**环形的队列**，取模: %
##### 使用数组模拟环形序列的思路
1. 对`front`变量的含义做调整:`front`指向队列的第一个元素，也就是说`arr[front]`就是队列的第一个元素，`front`初始值为0
2. 对`rear`变量的含义做调整:`rear`指向队列最后一个元素的后一个位置，空出空间作为约定，`rear`初始值为0
3. 当队列满时，条件为:`(rear+1)%maxSize=front`
4. 当队列为空的条件:`rear = front`
5. 队列中有效数据的个数`(rear+maxSize-front)%maxSize`
####代码
[数组模拟环形队列](src/com/yijie/queue/CircleArrayQueueDemo.java)

# 4. 链表
## 4.1 单链表
### 4.1.1 基本介绍
链表是有序的列表，在内存中存储方式如下:
![Example of SingleLinkedList](src/image/SingleLinkedList.png "SingleLinkedList")
* 链表是以节点的方式来存储，是链式存储
* 每个节点包含data域，next域:指向下一个节点
* 链表的各个节点不一定是连续存储
* 链表分带头节点的链表和不带头节点的链表

### 4.1.2 单链表的创建
1. 先创建一个`head`头节点，作用为表示链表的头
2. 依次添加后续节点到链表最后遍历
### 4.1.3 添加元素到链表指定位置
1. 通过**遍历**以及**辅助变量**`temp`找到新添加节点的位置
2. `新节点.next = temp.next`
3. `temp.next = 新节点`
### 4.1.4 修改链表中节点
1. 通过遍历找到该节点
2. 修改节点信息
### 4.1.5 从单链表中删除一个节点
1. 找到需要删除的节点的前一个节点`temp`
2. `temp.next = temp.next.next`
3. 被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收
### 4.1.6 代码
[单链表](src/com/yijie/linkedlist/SingleLinkedListDemo.java)
## 4.2双向链表
### 4.2.1 基本介绍
单链表缺点分析:
1. 单链表只能从一个方向进行查找，双向链表可以前向或者后向进行查找
2. 单项链表不能自我删除，需要依靠辅助节点，双向可以**自我删除**
### 4.2.2 双向链表的创建及增删改查操作
1. 遍历方法与单链表一直，区别:可以前向，也可后向查找
2. **添加**:默认添加到双向链表最后
   1. 找到双向链表的最后节点
   2. `temp.next = newHeroNode`
   3. `newHeroNode.pre = temp`
3. **修改**的思路及原理与单向链表一致
4. **删除**:
   1. 双向链表可实现自我删除
   2. 直接定位到待删除节点`temp`
   3. `temp.pre.next = temp.next`
   4. `temp.next.pre = temp.pre`
### 4.2.3 代码
[双向链表](src/com/yijie/linkedlist/DoubleLinkedListDemo.java)
## 4.3 单向环形链表
### 4.3.1 单向环形链表的应用: Josephus Problem
Josephu问题:编号为1,2,...,n的n个人围坐一圈，约定编号为k(1<=k<=n)的人从1开始报数，数到m的人出列，m的下一位继续从0开始报数。依次类推，直到所有人出列为止，由此产生一个出列编号的序列。

![Josephus Problem](src/image/JosephusProblem.png "Josephus Problem")

*示例:
  * n=5,共有5人
  * k=1,从第一人开始报数
  * m=2,数两次
  * 出队列顺序:
    * 2=>4=>1=>5=>3
### 4.3.2 单向环形链表的创建及操作
1. **创建**一个单向环形链表
   1. 创建第一个节点，让first指针指向该节点，并形成环形
   2. 之后每创建一个新节点，就把该节点加入到已有的环形链表即可
2. **遍历**单向环形链表
   1. 先让一个辅助指针指向first节点
   2. 后通过一个while循环遍历该链表即可(`cur.next first`)
### 4.3.3 代码
[单向环形链表及Josephu Problem](src/com/yijie/linkedlist/JosephuProblem.java)

# 5. 栈
## 4.1 单链表
### 4.1.1 基本介绍
1. 栈是一个先入先出的有序列表
2. 栈是限制线性表中元素的插入与删除**只能在线性表同一端**进行的一种特殊线性表。允许插入与删除的一段，为变化的一端，称为**栈顶**(Top),另一端为固定的一端，称为**栈底**(Bottom)。
3. 由栈的特性可知，最先放入栈的元素在栈底，最后放入栈的元素在栈顶。而删除元素恰好相反，最后放入的元素最先删除，最先放入的元素最后删除。
   
![Stack](src/image/Stack.webp "Stack")
### 4.1.2 栈的应用场景
1. 子程序的调用:在跳往子程序前，会将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来程序。
2. 处理递归调用:与子程序的调用类似，除了存储下一个指令的地址外，也将参数，区域变量等数据存入堆栈中。
3. 表达式的转换[中缀表达式转后缀表达式]与求职
4. 二叉树的遍历
5. 图形的深度优先(depth-first)搜索法
### 4.1.2 数组模拟栈
1. 定义一个`top`来表示栈顶，初始化为-1
2. 入栈的操作，当有数据加入到栈时，`top++`;`stack[top] = data`
3. 出栈的操作，`int value = stack[top];top--; return value`
4. [代码](src/com/yijie/stack/ArrayStack.java)